/* Copyright (c) 2009-2015 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <assert.h>

#include <iostream>
#include <fstream>

#include "ClusterMetrics.h"
#include "Context.h"
#include "Cycles.h"
#include "Dispatch.h"
#include "ShortMacros.h"
#include "Crc32C.h"
#include "ObjectFinder.h"
#include "OptionParser.h"
#include "RamCloud.h"
#include "Tub.h"
#include "IndexLookup.h"
#include "TableEnumerator.h"

using namespace RAMCloud;

/**
 * A utility for partitioning the key/value pairs in an on-disk table image file
 * generated by the TableDownloader (or other such image generating utility)
 * into a given number of tablets. The hash function used is the same as the one
 * used in RAMCloud, so the resulting contents of the tablet image files will
 * exactly match the contents of RAMCloud tablets for that table when divided
 * into the same number of tablets via the "serverSpan" parameter. 
 *
 * The purpose of this utility is to help improve the efficiency of uploading
 * table images to RAMCloud. By partitioning into tablets that match RAMCloud's
 * partitioning algorithm, each upload of a tablet involves bulk writing data to
 * 1 server, instead of shotgunning the data across the whole cluster.
 */
int
main(int argc, char *argv[])
try
{
  uint64_t tableId;
  uint64_t serverSpan;
  string outputDir;

  // Set line buffering for stdout so that printf's and log messages
  // interleave properly.
  setvbuf(stdout, NULL, _IOLBF, 1024);

  // Need external context to set log levels with OptionParser
  Context context(false);

  OptionsDescription clientOptions("ImageFileHashPartitioner");
  clientOptions.add_options()

    ("tableId",
     ProgramOptions::value<uint64_t>(&tableId),
     "TableId this table will have when loaded into RAMCloud.")
    ("serverSpan",
     ProgramOptions::value<uint64_t>(&serverSpan),
     "Number of tablets to partition the image file across.")
    ("outputDir",
     ProgramOptions::value<string>(&outputDir),
     "Directory to write tablets in.");
  
  OptionParser optionParser(clientOptions, argc, argv);

  printf("ImageFileHashPartitioner: {tableId: %lu, serverSpan: %lu, "
      "outputDir: %s}\n", tableId, serverSpan, outputDir.c_str());

  // Calculate the hash range for each tablet and open tablet image files.
  uint64_t endKeyHashes[serverSpan];
  uint64_t tabletRange = 1 + ~0UL / serverSpan;
  std::ofstream outFiles[serverSpan];
  for (uint32_t i = 0; i < serverSpan; i++) {
    uint64_t startKeyHash = i * tabletRange;
    uint64_t endKeyHash = startKeyHash + tabletRange - 1;
    if (i == (serverSpan - 1))
      endKeyHash = ~0UL;

    endKeyHashes[i] = endKeyHash;

    char *outFileName;
    asprintf(&outFileName, (outputDir + 
          "/tablet%4d(tableId:%lu,range:0x%16lx-0x%16lx).img").c_str(), 
        i + 1, tableId, startKeyHash, endKeyHash); 
    outFiles[i].open(outFileName, std::ios::binary);
    printf("Creating %s... ", outFileName);
    free(outFileName);
  }

  uint64_t totalBytesProcessed = 0;
  char lenBuffer[sizeof(uint32_t)];
  while(std::cin.read(lenBuffer, sizeof(lenBuffer))) {
    uint32_t keyLength = *((uint32_t*) lenBuffer); 
    char keyBuffer[keyLength];
    std::cin.read(keyBuffer, keyLength);
    
    std::cin.read(lenBuffer, sizeof(lenBuffer));
    uint32_t dataLength = *((uint32_t*) lenBuffer);
    char dataBuffer[dataLength];
    std::cin.read(dataBuffer, dataLength);

    uint64_t keyHash = Key::getHash(tableId, (const void*)keyBuffer, 
        (uint16_t)keyLength);

    uint64_t tablet = 0;
    for (uint32_t i = 0; i < serverSpan; i++) {
      if (keyHash <= endKeyHashes[i]) {
        tablet = i;
        break;
      }
    }

    outFiles[tablet].write((char*) &keyLength, sizeof(uint32_t));
    outFiles[tablet].write((char*) keyBuffer, keyLength);
    outFiles[tablet].write((char*) &dataLength, sizeof(uint32_t));
    outFiles[tablet].write((char*) dataBuffer, dataLength);

    totalBytesProcessed += sizeof(uint32_t) * 2 + keyLength + dataLength;
  }

  for (uint32_t i = 0; i < serverSpan; i++) {
    outFiles[i].close();
  }

  printf("Partitioned table image into %lu tablets.\n", serverSpan);

  return 0;
} catch (Exception& e) {
    fprintf(stderr, "Exception: %s\n", e.str().c_str());
    return 1;
}

