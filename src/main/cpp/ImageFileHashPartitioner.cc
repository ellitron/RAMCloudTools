/* Copyright (c) 2009-2015 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <assert.h>

#include <iostream>
#include <fstream>
#include <istream>

#include "ClusterMetrics.h"
#include "Context.h"
#include "Cycles.h"
#include "Dispatch.h"
#include "ShortMacros.h"
#include "Crc32C.h"
#include "ObjectFinder.h"
#include "OptionParser.h"
#include "RamCloud.h"
#include "Tub.h"
#include "IndexLookup.h"
#include "TableEnumerator.h"

using namespace RAMCloud;

/**
 * A utility for partitioning the key/value pairs in an on-disk table image file
 * generated by the TableDownloader (or other such image generating utility)
 * into a given number of tablets. The hash function used is the same as the one
 * used in RAMCloud, so the resulting contents of the tablet image files will
 * exactly match the contents of RAMCloud tablets for that table when divided
 * into the same number of tablets via the "serverSpan" parameter. 
 *
 * The purpose of this utility is to help improve the efficiency of uploading
 * table images to RAMCloud. By partitioning into tablets that match RAMCloud's
 * partitioning algorithm, each upload of a tablet involves bulk writing data to
 * 1 server, instead of shotgunning the data across the whole cluster.
 */
int
main(int argc, char *argv[])
try
{
  string inputFile;
  uint64_t tableId;
  uint64_t serverSpan;
  string outputDir;

  // Set line buffering for stdout so that printf's and log messages
  // interleave properly.
  setvbuf(stdout, NULL, _IOLBF, 1024);

  // Need external context to set log levels with OptionParser
  Context context(false);

  OptionsDescription clientOptions("ImageFileHashPartitioner");
  clientOptions.add_options()

    ("inputFile",
     ProgramOptions::value<string>(&inputFile),
     "Input file for hash partitioning. If '-' then takes input from stdin.")
    ("tableId",
     ProgramOptions::value<uint64_t>(&tableId),
     "TableId this table will have when loaded into RAMCloud.")
    ("serverSpan",
     ProgramOptions::value<uint64_t>(&serverSpan),
     "Number of tablets to partition the image file across.")
    ("outputDir",
     ProgramOptions::value<string>(&outputDir),
     "Directory to write tablets in.");
  
  OptionParser optionParser(clientOptions, argc, argv);

  printf("ImageFileHashPartitioner: {inputFile: %s, tableId: %lu, "
      "serverSpan: %lu, outputDir: %s}\n", inputFile.c_str(), tableId, 
      serverSpan, outputDir.c_str());

  // Calculate the hash range for each tablet and open tablet image files.
  uint64_t endKeyHashes[serverSpan];
  uint64_t tabletRange = 1 + ~0UL / serverSpan;
  std::ofstream outFiles[serverSpan];
  for (uint32_t i = 0; i < serverSpan; i++) {
    uint64_t startKeyHash = i * tabletRange;
    uint64_t endKeyHash = startKeyHash + tabletRange - 1;
    if (i == (serverSpan - 1))
      endKeyHash = ~0UL;

    endKeyHashes[i] = endKeyHash;

    char *outFileName;
    if (inputFile.compare("-") == 0 || inputFile.empty()) {
      asprintf(&outFileName, (outputDir + 
            "/tablet%d(tableId:%lu,range:0x%016lx-0x%016lx).img").c_str(), 
          i + 1, tableId, startKeyHash, endKeyHash); 
    } else {
      string fileName = inputFile.substr(inputFile.find_last_of("/")+1);
      asprintf(&outFileName, (outputDir + 
            "/%s.tablet%d(tableId:%lu,range:0x%016lx-0x%016lx).img").c_str(), 
          fileName.substr(0,fileName.find(".img")).c_str(),
          i + 1, tableId, startKeyHash, endKeyHash); 
    }
    outFiles[i].open(outFileName, std::ios::binary);
    printf("Creating %s ...\n", outFileName);
    free(outFileName);
  }

  if (inputFile.compare("-") == 0) {
    uint64_t totalBytesProcessed = 0;
    char lenBuffer[sizeof(uint32_t)];
    while(std::cin.read(lenBuffer, sizeof(lenBuffer))) {
      uint32_t keyLength = *((uint32_t*) lenBuffer); 
      char keyBuffer[keyLength];
      std::cin.read(keyBuffer, keyLength);
      
      std::cin.read(lenBuffer, sizeof(lenBuffer));
      uint32_t dataLength = *((uint32_t*) lenBuffer);
      char dataBuffer[dataLength];
      std::cin.read(dataBuffer, dataLength);

      uint64_t keyHash = Key::getHash(tableId, (const void*)keyBuffer, 
          (uint16_t)keyLength);

      uint64_t tablet = 0;
      for (uint32_t i = 0; i < serverSpan; i++) {
        if (keyHash <= endKeyHashes[i]) {
          tablet = i;
          break;
        }
      }

      outFiles[tablet].write((char*) &keyLength, sizeof(uint32_t));
      outFiles[tablet].write((char*) keyBuffer, keyLength);
      outFiles[tablet].write((char*) &dataLength, sizeof(uint32_t));
      outFiles[tablet].write((char*) dataBuffer, dataLength);

      totalBytesProcessed += sizeof(uint32_t) * 2 + keyLength + dataLength;
    }
  } else {
    std::ifstream infile(inputFile);

    uint64_t totalBytesProcessed = 0;
    char lenBuffer[sizeof(uint32_t)];
    while(infile.read(lenBuffer, sizeof(lenBuffer))) {
      uint32_t keyLength = *((uint32_t*) lenBuffer); 
      char keyBuffer[keyLength];
      infile.read(keyBuffer, keyLength);
      
      infile.read(lenBuffer, sizeof(lenBuffer));
      uint32_t dataLength = *((uint32_t*) lenBuffer);
      char dataBuffer[dataLength];
      infile.read(dataBuffer, dataLength);

      uint64_t keyHash = Key::getHash(tableId, (const void*)keyBuffer, 
          (uint16_t)keyLength);

      uint64_t tablet = 0;
      for (uint32_t i = 0; i < serverSpan; i++) {
        if (keyHash <= endKeyHashes[i]) {
          tablet = i;
          break;
        }
      }

      outFiles[tablet].write((char*) &keyLength, sizeof(uint32_t));
      outFiles[tablet].write((char*) keyBuffer, keyLength);
      outFiles[tablet].write((char*) &dataLength, sizeof(uint32_t));
      outFiles[tablet].write((char*) dataBuffer, dataLength);

      totalBytesProcessed += sizeof(uint32_t) * 2 + keyLength + dataLength;
    }
  }

  for (uint32_t i = 0; i < serverSpan; i++) {
    outFiles[i].close();
  }

  printf("Done! Partitioned table image into %lu tablets.\n", serverSpan);

  return 0;
} catch (Exception& e) {
    fprintf(stderr, "Exception: %s\n", e.str().c_str());
    return 1;
}

