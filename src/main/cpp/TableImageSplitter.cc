/* Copyright (c) 2009-2015 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <assert.h>

#include <iostream>
#include <fstream>

#include "ClusterMetrics.h"
#include "Context.h"
#include "Cycles.h"
#include "Dispatch.h"
#include "ShortMacros.h"
#include "Crc32C.h"
#include "ObjectFinder.h"
#include "OptionParser.h"
#include "RamCloud.h"
#include "Tub.h"
#include "IndexLookup.h"
#include "TableEnumerator.h"

using namespace RAMCloud;

/**
 * A utility for splitting table images generated by the TableDownloader
 * into chunks of equal size (measured in RAMCloud objects). Once split, those
 * parts can be uploaded in parallel by the TableUploader.
 */
int
main(int argc, char *argv[])
try
{
  string imageFilePath;
  long objectsPerFile;
  string outputDir;
  string splitSuffixFormat;

  // Set line buffering for stdout so that printf's and log messages
  // interleave properly.
  setvbuf(stdout, NULL, _IOLBF, 1024);

  // Need external context to set log levels with OptionParser
  Context context(false);

  OptionsDescription clientOptions("TableImageSplitter");
  clientOptions.add_options()

    ("imageFile",
     ProgramOptions::value<string>(&imageFilePath),
     "Path to the image file to split.")
    ("objectsPerFile",
     ProgramOptions::value<long>(&objectsPerFile),
     "How many objects to pack into a partition.")
    ("outputDir",
     ProgramOptions::value<string>(&outputDir),
     "Directory to write split files.")
    ("splitSuffixFormat",
     ProgramOptions::value<string>(&splitSuffixFormat)->
         default_value(".part%04d"),
     "Format string of the suffix to use for partitions. Must contain "
         "exactly one %d. [default: \".part%04d\"].");
  
  OptionParser optionParser(clientOptions, argc, argv);

  printf("TableImageSplitter: {imageFile: %s, objectsPerFile: %u, "
      "outputDir: %s, splitSuffixFormat: %s}\n", imageFilePath.c_str(), 
      objectsPerFile, outputDir.c_str(), splitSuffixFormat.c_str());

  // Open image file for splitting. 
  std::ifstream inFile;
  inFile.open(imageFilePath.c_str(), std::ios::binary);

  size_t lastSlashIndex = imageFilePath.find_last_of("/");
  string imageFileName;
  if (lastSlashIndex != string::npos)
    imageFileName = imageFilePath.substr(lastSlashIndex + 1);
  else 
    imageFileName = imageFilePath;

  long partitionCount = 0; // How many partitions we've created so far.
  long objCount = 0; // How many objects are in the current partition.
  long totalObjCount = 0; // How many objects have we copied in total.
  long byteCount = 0; // How many total bytes have we copied so far.

  // Open initial output file for first partition.
  char *outFileName;
  asprintf(&outFileName, 
      (outputDir + "/" + imageFileName + splitSuffixFormat).c_str(),
      partitionCount); 
  std::ofstream outFile;
  outFile.open(outFileName, std::ios::binary);
  printf("Creating %s... ", outFileName);
  free(outFileName);

  // Read the imagefile until there are no more objects left in the file.
  char lenBuffer[sizeof(uint32_t)];
  while(inFile.read(lenBuffer, sizeof(lenBuffer))) {
    uint32_t keyLength = *((uint32_t*) lenBuffer); 
    char keyBuffer[keyLength];
    inFile.read(keyBuffer, keyLength);
    
    inFile.read(lenBuffer, sizeof(lenBuffer));
    uint32_t dataLength = *((uint32_t*) lenBuffer);
    char dataBuffer[dataLength];
    inFile.read(dataBuffer, dataLength);

    // Copy object to output file.
    outFile.write((char*) &keyLength, sizeof(uint32_t));
    outFile.write((char*) keyBuffer, keyLength);
    outFile.write((char*) &dataLength, sizeof(uint32_t));
    outFile.write((char*) dataBuffer, dataLength);

    objCount++;
    totalObjCount++;
    byteCount += keyLength + dataLength;

    // If we've filled up the partition, close it and start a new one.
    if (objCount == objectsPerFile) {
      outFile.close();
      partitionCount++;
      printf("Done\n");

      asprintf(&outFileName, 
          (outputDir + "/" + imageFileName + splitSuffixFormat).c_str(),
          partitionCount); 
      outFile.open(outFileName, std::ios::binary);
      printf("Creating %s... ", outFileName);
      free(outFileName);
      
      objCount = 0;
    }
  }

  outFile.close();
  partitionCount++;
  printf("Done\n");

  inFile.close();

  printf("Split table image into %u partitions. Total objects: %u. Total "
      "bytes: %u\n", partitionCount, totalObjCount, byteCount);

  return 0;
} catch (Exception& e) {
    fprintf(stderr, "Exception: %s\n", e.str().c_str());
    return 1;
}

